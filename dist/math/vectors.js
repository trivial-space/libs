// Generated by github.com/steida/coffee2closure 0.1.9
goog.provide('tslibs.math.vectors');
goog.scope(function() {
  var fns;
  fns = tslibs.math.vectors;
  fns.add = function(vec1, vec2) {
    var i, _i, _ref, _results;
    _results = [];
    for (i = _i = 0, _ref = vec1.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      _results.push(vec1[i] + vec2[i]);
    }
    return _results;
  };
  fns.addScalar = function(vec, scalar) {
    var i, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = vec.length; _i < _len; _i++) {
      i = vec[_i];
      _results.push(i + scalar);
    }
    return _results;
  };
  fns.sub = function(vec1, vec2) {
    var i, _i, _ref, _results;
    _results = [];
    for (i = _i = 0, _ref = vec1.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      _results.push(vec1[i] - vec2[i]);
    }
    return _results;
  };
  fns.subScalar = function(vec, scalar) {
    var i, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = vec.length; _i < _len; _i++) {
      i = vec[_i];
      _results.push(i - scalar);
    }
    return _results;
  };
  fns.mul = function(vec, scalar) {
    var val, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = vec.length; _i < _len; _i++) {
      val = vec[_i];
      _results.push(val * scalar);
    }
    return _results;
  };
  fns.div = function(vec, scalar) {
    var val, _i, _len, _results;
    if (scalar) {
      _results = [];
      for (_i = 0, _len = vec.length; _i < _len; _i++) {
        val = vec[_i];
        _results.push(val / scalar);
      }
      return _results;
    }
  };
  fns.length = function(vec) {
    var sum, val, _i, _len;
    sum = 0;
    for (_i = 0, _len = vec.length; _i < _len; _i++) {
      val = vec[_i];
      sum += val * val;
    }
    return Math.sqrt(sum);
  };
  fns.normalize = function(vec) {
    return fns.div(vec, fns.length(vec));
  };
  fns.limit = function(vec, maxLenght) {
    if (maxLenght < fns.length(vec)) {
      return fns.mul(fns.normalize(vec), maxLenght);
    } else {
      return vec;
    }
  };
  return fns.isEqual = function(vec1, vec2) {
    var equal, i, _i, _ref;
    equal = true;
    for (i = _i = 0, _ref = vec1.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (vec1[i] !== vec2[i]) {
        equal = false;
      }
    }
    return equal;
  };
});