// Generated by github.com/steida/coffee2closure 0.1.9
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.superClass_ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;
goog.provide('tslibs.graphics.PixelContext');
goog.require('tslibs.graphics');
goog.require('goog.object');
tslibs.graphics.PixelContext = function(imageData) {
  this.imageData = imageData;
  this.data = this.imageData.data;
  this.width = this.imageData.width;
  this.height = this.imageData.height;
}
tslibs.graphics.PixelContext.prototype.adjustPos = function(pos) {
  return pos;
};
tslibs.graphics.PixelContext.prototype.getPixelIndex = function(pos) {
  var ref, x, y;
  ref = this.adjustPos(pos), x = ref[0], y = ref[1];
  return (y * this.height + x) * 4;
};
tslibs.graphics.PixelContext.prototype.getColorAt = function(pos) {
  var i;
  i = this.getPixelIndex(pos);
  return [this.data[i], this.data[i + 1], this.data[i + 2], this.data[i + 3]];
};
tslibs.graphics.PixelContext.prototype.setColorAt = function(pos, color) {
  var i;
  i = this.getPixelIndex(pos);
  this.data[i] = color[0];
  this.data[i + 1] = color[1];
  this.data[i + 2] = color[2];
  return this.data[i + 3] = color[3];
};
tslibs.graphics.PixelContext.prototype.increaseAllBy = function(arg) {
  var a, b, d, g, i, k, r, ref, results;
  r = arg[0], g = arg[1], b = arg[2], a = arg[3];
  d = this.data;
  results = [];
  for (i = k = 0, ref = d.length - 1; k <= ref; i = k += 4) {
    if (d[i] + r < 256) {
      d[i] += r;
    }
    if (d[i + 1] + g < 256) {
      d[i + 1] += g;
    }
    if (d[i + 2] + b < 256) {
      d[i + 2] += b;
    }
    if (d[i + 3] + a < 256) {
      results.push(d[i + 3] += a);
    } else {
      results.push(void 0);
    }
  }
  return results;
};
tslibs.graphics.PixelContext.prototype.decreaseAllBy = function(arg) {
  var a, b, d, g, i, k, r, ref, results;
  r = arg[0], g = arg[1], b = arg[2], a = arg[3];
  d = this.data();
  results = [];
  for (i = k = 0, ref = d.length - 1; k <= ref; i = k += 4) {
    if (r <= d[i]) {
      d[i] -= r;
    }
    if (g <= d[i + 1]) {
      d[i + 1] -= g;
    }
    if (b <= d[i + 2]) {
      d[i + 2] -= b;
    }
    if (a <= d[i + 3]) {
      results.push(d[i + 3] -= a);
    } else {
      results.push(void 0);
    }
  }
  return results;
};
tslibs.graphics.PixelContext.prototype.replaceWithImageDataAt = function(pixelCtx, arg) {
  var h, i, j, k, ref, results, w, x, y;
  x = arg[0], y = arg[1];
  w = pixelCtx.width - 1;
  h = pixelCtx.height - 1;
  results = [];
  for (i = k = 0, ref = w; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
    results.push((function() {
      var l, ref1, results1;
      results1 = [];
      for (j = l = 0, ref1 = h; 0 <= ref1 ? l <= ref1 : l >= ref1; j = 0 <= ref1 ? ++l : --l) {
        results1.push(this.setColorAt([x + i, y + j], pixelCtx.getColorAt([i, j])));
      }
      return results1;
    }).call(this));
  }
  return results;
};
tslibs.graphics.PixelContext.prototype.drawImageAt = function(pixelCtx, arg) {
  var h, i, j, k, ref, results, w, x, y;
  x = arg[0], y = arg[1];
  w = pixelCtx.width() - 1;
  h = pixelCtx.height() - 1;
  results = [];
  for (i = k = 0, ref = w; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
    results.push((function() {
      var l, ref1, results1;
      results1 = [];
      for (j = l = 0, ref1 = h; 0 <= ref1 ? l <= ref1 : l >= ref1; j = 0 <= ref1 ? ++l : --l) {
        results1.push(this.setColorAt([x + i, y + j], tslibs.graphics.mixColors(this.getColorAt([x + i, y + j]), pixelCtx.getColorAt([i, j]))));
      }
      return results1;
    }).call(this));
  }
  return results;
};
tslibs.graphics.PixelContext.prototype.mixinColor = function(color) {
  var h, k, ref, results, w, x, y;
  w = this.imageData.width - 1;
  h = this.imageData.height - 1;
  results = [];
  for (x = k = 0, ref = w; 0 <= ref ? k <= ref : k >= ref; x = 0 <= ref ? ++k : --k) {
    results.push((function() {
      var l, ref1, results1;
      results1 = [];
      for (y = l = 0, ref1 = h; 0 <= ref1 ? l <= ref1 : l >= ref1; y = 0 <= ref1 ? ++l : --l) {
        results1.push(this.setColorAt([x, y], tslibs.graphics.mixColors(this.getColorAt([x, y]), color)));
      }
      return results1;
    }).call(this));
  }
  return results;
};
tslibs.graphics.ClosedPixelContext = function() {
  return tslibs.graphics.ClosedPixelContext.superClass_.constructor.apply(this, arguments);
}
extend(tslibs.graphics.ClosedPixelContext, superClass);
tslibs.graphics.ClosedPixelContext.prototype.adjustPos = function(arg) {
  var h, w, x, y;
  x = arg[0], y = arg[1];
  w = this.width;
  h = this.height;
  if (x < 0) {
    x = 0;
  }
  if (y < 0) {
    y = 0;
  }
  if (x >= w) {
    x = w;
  }
  if (y >= h) {
    y = h;
  }
  return [x, y];
};
tslibs.graphics.RepeatedPixelContext = function() {
  return tslibs.graphics.RepeatedPixelContext.superClass_.constructor.apply(this, arguments);
}
extend(tslibs.graphics.RepeatedPixelContext, superClass);
tslibs.graphics.RepeatedPixelContext.prototype.adjustPos = function(arg) {
  var h, w, x, y;
  x = arg[0], y = arg[1];
  w = this.width;
  h = this.height;
  if (x >= w) {
    x -= w;
  }
  if (y >= h) {
    y -= h;
  }
  if (x < 0) {
    x += w;
  }
  if (y < 0) {
    y += h;
  }
  return [x, y];
};
tslibs.graphics.createCtxFromImg = function(img, ContextClass) {
  var c, ctx, imgData;
  c = document.createElement("canvas");
  c.width = img.width;
  c.height = img.height;
  ctx = c.getContext("2d");
  ctx.drawImage(img, 0, 0, img.width, img.height);
  imgData = ctx.getImageData(0, 0, img.width, img.height);
  return new ContextClass(imgData);
};